/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as url from 'url';
import * as zlib from 'zlib';
import Debug from 'debug';
import { getVersion } from '../../utils';
import * as utils from '../utils';
import { prepareData, parseResponse, combineURL, set as setHeader, normalizeHeaders } from './../helpers';
import { FsRequestErrorCode, FsRequestError } from '../error';
var HTTPS_REGEXP = /https:?/;
var MAX_REDIRECTS = 10;
var CANCEL_CLEAR = "FsCleanMemory";
var debug = Debug('fs:request:http');
var HttpAdapter = /** @class */ (function () {
    function HttpAdapter() {
        this.redirectHoops = 0;
        this.redirectPaths = [];
    }
    HttpAdapter.prototype.request = function (config) {
        var _this = this;
        // if this option is unspecified set it by default
        if (typeof config.filestackHeaders === 'undefined') {
            config.filestackHeaders = true;
        }
        config.headers = normalizeHeaders(config.headers);
        var _a = prepareData(config), data = _a.data, headers = _a.headers;
        headers = setHeader(headers, 'user-agent', "filestack-request/" + getVersion());
        // for now we are not using streams
        if (data) {
            debug('Request data %O', data);
            if (!Buffer.isBuffer(data)) {
                if (!utils.isString(data)) {
                    return Promise.reject(new FsRequestError('Data must be a string, JSON or a Buffer', config));
                }
                data = Buffer.from(data, 'utf-8');
            }
            headers = setHeader(headers, 'content-length', data.length, true);
        }
        // HTTP basic authentication
        var auth;
        if (config.auth) {
            if (!config.auth.username || config.auth.username.length === 0) {
                return Promise.reject(new FsRequestError("Basic auth: username is required " + config.auth, config));
            }
            auth = config.auth.username + ":" + config.auth.password;
        }
        // Parse url
        var parsed = url.parse(config.url);
        // try to add default https protocol
        if (!parsed.protocol) {
            parsed = url.parse("https://" + config.url);
        }
        /* istanbul ignore next: just be sure that the host is parsed correctly, not needed to test */
        if (!parsed.host) {
            return Promise.reject(new FsRequestError("Cannot parse provided url " + config.url, config));
        }
        // normalize auth header
        if (auth && headers.Authorization) {
            delete headers.Authorization;
        }
        var isHttpsRequest = HTTPS_REGEXP.test(parsed.protocol);
        var agent = isHttpsRequest ? require('https') : require('http');
        var options = {
            path: combineURL(parsed.path, config.params),
            host: parsed.host,
            port: parsed.port,
            protocol: parsed.protocol,
            method: config.method.toUpperCase(),
            headers: headers,
            agent: new agent.Agent(),
            auth: auth,
        };
        debug('Starting %s request with options %O', isHttpsRequest ? 'https' : 'http', options);
        return new Promise(function (resolve, reject) {
            var req = agent.request(options, function (res) {
                /* istanbul ignore next: just be sure that response will not be called after request is aborted */
                if (!req || req.aborted) {
                    return reject(new FsRequestError('Request aborted', config));
                }
                var stream = res;
                debug('Response statusCode: %d, Response Headers: %O', res.statusCode, res.headers);
                var compressHeaders = res.headers['content-encoding'];
                if (compressHeaders && compressHeaders.length && ['gzip', 'compress', 'deflate'].some(function (v) { return compressHeaders.indexOf(v) > -1; })) {
                    // add the unzipper to the body stream processing pipeline
                    stream = res.statusCode === 204 ? stream : stream.pipe(zlib.createUnzip());
                    // remove the content-encoding in order to not confuse downstream operations
                    delete res.headers['content-encoding'];
                }
                var response = {
                    status: res.statusCode,
                    statusText: res.statusMessage,
                    headers: res.headers,
                    config: config,
                    data: {},
                };
                // we need to follow redirect so make same request with new location
                if ([301, 302].indexOf(res.statusCode) > -1) {
                    debug('Redirect received %s', res.statusCode);
                    if (_this.redirectHoops >= MAX_REDIRECTS) {
                        return reject(new FsRequestError("Max redirects (" + _this.redirectHoops + ") reached. Exiting", config, response, FsRequestErrorCode.REDIRECT));
                    }
                    var url_1 = res.headers['location'];
                    if (!url_1 || url_1.length === 0) {
                        return reject(new FsRequestError("Redirect header location not found", config, response, FsRequestErrorCode.REDIRECT));
                    }
                    if (_this.redirectPaths.indexOf(url_1) > -1) {
                        return reject(new FsRequestError("Redirect loop detected at url " + url_1, config, response, FsRequestErrorCode.REDIRECT));
                    }
                    _this.redirectPaths.push(url_1);
                    _this.redirectHoops++;
                    // free resources
                    res = undefined;
                    req = undefined;
                    debug('Redirecting request to %s (hoop-count: %d)', url_1, _this.redirectHoops);
                    // clear cancel token to avoid memory leak
                    if (config.cancelToken) {
                        config.cancelToken.cancel(CANCEL_CLEAR);
                    }
                    return resolve(_this.request(Object.assign({}, config, { url: url_1 })));
                }
                var responseBuffer = [];
                stream.on('data', function (chunk) { return responseBuffer.push(chunk); });
                /* istanbul ignore next: its hard to test socket events with jest and nock - tested manually */
                stream.on('error', function (err) {
                    res = undefined;
                    req = undefined;
                    responseBuffer = undefined;
                    debug('Request error: Aborted %O', err);
                    if (req.aborted) {
                        return;
                    }
                    return reject(new FsRequestError(err.message, config, null, FsRequestErrorCode.NETWORK));
                });
                stream.on('end', function () {
                    // check if there is any response data inside
                    if (res.statusCode !== 204) {
                        // prepare response
                        response.data = Buffer.concat(responseBuffer);
                        response = parseResponse(response);
                    }
                    else {
                        response.data = null;
                    }
                    // free resources
                    res = undefined;
                    req = undefined;
                    responseBuffer = undefined;
                    if (500 <= response.status && response.status <= 599) {
                        // server error throw
                        debug('Server error(5xx) - %O', response);
                        return reject(new FsRequestError("Server error " + url, config, response, FsRequestErrorCode.SERVER));
                    }
                    else if (400 <= response.status && response.status <= 499) {
                        debug('Request error(4xx) - %O', response);
                        return reject(new FsRequestError("Request error " + url, config, response, FsRequestErrorCode.REQUEST));
                    }
                    debug('Request ends: %O', response);
                    return resolve(response);
                });
            });
            if (config.cancelToken) {
                config.cancelToken
                    .getSource()
                    .then(function (reason) {
                    // do nothing if promise is resolved by system
                    if (reason && reason.message === CANCEL_CLEAR) {
                        return;
                    }
                    /* istanbul ignore next: if request is done cancel token should not throw any error */
                    if (req) {
                        req.abort();
                        req = null;
                    }
                    debug('Request canceled by user %s, config: %O', reason, config);
                    return reject(new FsRequestError("Request aborted. Reason: " + reason, config, null, FsRequestErrorCode.ABORTED));
                })
                    /* istanbul ignore next: only for safety */
                    .catch(function () { });
            }
            if (config.timeout) {
                req.setTimeout(config.timeout, function () {
                    req.abort();
                    return reject(new FsRequestError('Request timeout', config, null, FsRequestErrorCode.TIMEOUT));
                });
            }
            req.on('error', function (err) {
                if (!req || req.aborted) {
                    return;
                }
                debug('Request error: %s - %O', err, err.code);
                return reject(new FsRequestError("Request error: " + err.code, config, null, FsRequestErrorCode.NETWORK));
            });
            req.end(data);
        });
    };
    return HttpAdapter;
}());
export { HttpAdapter };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9hZGFwdGVycy9odHRwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sS0FBSyxHQUFHLE1BQU0sS0FBSyxDQUFDO0FBQzNCLE9BQU8sS0FBSyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQzdCLE9BQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUcxQixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRXpDLE9BQU8sS0FBSyxLQUFLLE1BQU0sVUFBVSxDQUFDO0FBQ2xDLE9BQU8sRUFBRSxXQUFXLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxHQUFHLElBQUksU0FBUyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQzFHLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxjQUFjLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFFOUQsSUFBTSxZQUFZLEdBQUcsU0FBUyxDQUFDO0FBQy9CLElBQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUN6QixJQUFNLFlBQVksR0FBRyxlQUFlLENBQUM7QUFDckMsSUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFFdkM7SUFBQTtRQUNVLGtCQUFhLEdBQUcsQ0FBQyxDQUFDO1FBQ2xCLGtCQUFhLEdBQUcsRUFBRSxDQUFDO0lBZ083QixDQUFDO0lBOU5DLDZCQUFPLEdBQVAsVUFBUSxNQUF3QjtRQUFoQyxpQkE2TkM7UUE1TkMsa0RBQWtEO1FBQ2xELElBQUksT0FBTyxNQUFNLENBQUMsZ0JBQWdCLEtBQUssV0FBVyxFQUFFO1lBQ2xELE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7U0FDaEM7UUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUU5QyxJQUFBLHdCQUF1QyxFQUFyQyxjQUFJLEVBQUUsb0JB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QU87aUJBQ1I7Z0JBRUQsS0FBSyxDQUFDLHdCQUF3QixFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQy9DLE9BQU8sTUFBTSxDQUFDLElBQUksY0FBYyxDQUFDLG9CQUFrQixHQUFHLENBQUMsSUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUM1RyxDQUFDLENBQUMsQ0FBQztZQUVILEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQ0gsa0JBQUM7QUFBRCxDQWxPQSxBQWtPQyxJQUFBIiwiZmlsZSI6ImxpYi9yZXF1ZXN0L2FkYXB0ZXJzL2h0dHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFja1xuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCAqIGFzIHVybCBmcm9tICd1cmwnO1xuaW1wb3J0ICogYXMgemxpYiBmcm9tICd6bGliJztcbmltcG9ydCBEZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5cbmltcG9ydCB7IEFkYXB0ZXJJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBnZXRWZXJzaW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgRnNSZXF1ZXN0T3B0aW9ucywgRnNSZXNwb25zZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHByZXBhcmVEYXRhLCBwYXJzZVJlc3BvbnNlLCBjb21iaW5lVVJMLCBzZXQgYXMgc2V0SGVhZGVyLCBub3JtYWxpemVIZWFkZXJzIH0gZnJvbSAnLi8uLi9oZWxwZXJzJztcbmltcG9ydCB7IEZzUmVxdWVzdEVycm9yQ29kZSwgRnNSZXF1ZXN0RXJyb3IgfSBmcm9tICcuLi9lcnJvcic7XG5cbmNvbnN0IEhUVFBTX1JFR0VYUCA9IC9odHRwczo/LztcbmNvbnN0IE1BWF9SRURJUkVDVFMgPSAxMDtcbmNvbnN0IENBTkNFTF9DTEVBUiA9IGBGc0NsZWFuTWVtb3J5YDtcbmNvbnN0IGRlYnVnID0gRGVidWcoJ2ZzOnJlcXVlc3Q6aHR0cCcpO1xuXG5leHBvcnQgY2xhc3MgSHR0cEFkYXB0ZXIgaW1wbGVtZW50cyBBZGFwdGVySW50ZXJmYWNlIHtcbiAgcHJpdmF0ZSByZWRpcmVjdEhvb3BzID0gMDtcbiAgcHJpdmF0ZSByZWRpcmVjdFBhdGhzID0gW107XG5cbiAgcmVxdWVzdChjb25maWc6IEZzUmVxdWVzdE9wdGlvbnMpIHtcbiAgICAvLyBpZiB0aGlzIG9wdGlvbiBpcyB1bnNwZWNpZmllZCBzZXQgaXQgYnkgZGVmYXVsdFxuICAgIGlmICh0eXBlb2YgY29uZmlnLmZpbGVzdGFja0hlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWcuZmlsZXN0YWNrSGVhZGVycyA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uZmlnLmhlYWRlcnMgPSBub3JtYWxpemVIZWFkZXJzKGNvbmZpZy5oZWFkZXJzKTtcblxuICAgIGxldCB7IGRhdGEsIGhlYWRlcnMgfSA9IHByZXBhcmVEYXRhKGNvbmZpZyk7XG5cbiAgICBoZWFkZXJzID0gc2V0SGVhZGVyKGhlYWRlcnMsICd1c2VyLWFnZW50JywgYGZpbGVzdGFjay1yZXF1ZXN0LyR7Z2V0VmVyc2lvbigpfWApO1xuXG4gICAgLy8gZm9yIG5vdyB3ZSBhcmUgbm90IHVzaW5nIHN0cmVhbXNcbiAgICBpZiAoZGF0YSkge1xuICAgICAgZGVidWcoJ1JlcXVlc3QgZGF0YSAlTycsIGRhdGEpO1xuXG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcignRGF0YSBtdXN0IGJlIGEgc3RyaW5nLCBKU09OIG9yIGEgQnVmZmVyJywgY29uZmlnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0Zi04Jyk7XG4gICAgICB9XG5cbiAgICAgIGhlYWRlcnMgPSBzZXRIZWFkZXIoaGVhZGVycywgJ2NvbnRlbnQtbGVuZ3RoJywgZGF0YS5sZW5ndGgsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBsZXQgYXV0aDtcbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIGlmICghY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgY29uZmlnLmF1dGgudXNlcm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYEJhc2ljIGF1dGg6IHVzZXJuYW1lIGlzIHJlcXVpcmVkICR7Y29uZmlnLmF1dGh9YCwgY29uZmlnKSk7XG4gICAgICB9XG5cbiAgICAgIGF1dGggPSBgJHtjb25maWcuYXV0aC51c2VybmFtZX06JHtjb25maWcuYXV0aC5wYXNzd29yZH1gO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHVybFxuICAgIGxldCBwYXJzZWQgPSB1cmwucGFyc2UoY29uZmlnLnVybCk7XG5cbiAgICAvLyB0cnkgdG8gYWRkIGRlZmF1bHQgaHR0cHMgcHJvdG9jb2xcbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCkge1xuICAgICAgcGFyc2VkID0gdXJsLnBhcnNlKGBodHRwczovLyR7Y29uZmlnLnVybH1gKTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDoganVzdCBiZSBzdXJlIHRoYXQgdGhlIGhvc3QgaXMgcGFyc2VkIGNvcnJlY3RseSwgbm90IG5lZWRlZCB0byB0ZXN0ICovXG4gICAgaWYgKCFwYXJzZWQuaG9zdCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgQ2Fubm90IHBhcnNlIHByb3ZpZGVkIHVybCAke2NvbmZpZy51cmx9YCwgY29uZmlnKSk7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIGF1dGggaGVhZGVyXG4gICAgaWYgKGF1dGggJiYgaGVhZGVycy5BdXRob3JpemF0aW9uKSB7XG4gICAgICBkZWxldGUgaGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGlzSHR0cHNSZXF1ZXN0ID0gSFRUUFNfUkVHRVhQLnRlc3QocGFyc2VkLnByb3RvY29sKTtcbiAgICBjb25zdCBhZ2VudCA9IGlzSHR0cHNSZXF1ZXN0ID8gcmVxdWlyZSgnaHR0cHMnKSA6IHJlcXVpcmUoJ2h0dHAnKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXRoOiBjb21iaW5lVVJMKHBhcnNlZC5wYXRoLCBjb25maWcucGFyYW1zKSxcbiAgICAgIGhvc3Q6IHBhcnNlZC5ob3N0LFxuICAgICAgcG9ydDogcGFyc2VkLnBvcnQsXG4gICAgICBwcm90b2NvbDogcGFyc2VkLnByb3RvY29sLFxuICAgICAgbWV0aG9kOiBjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgYWdlbnQ6IG5ldyBhZ2VudC5BZ2VudCgpLFxuICAgICAgYXV0aDogYXV0aCxcbiAgICB9O1xuXG4gICAgZGVidWcoJ1N0YXJ0aW5nICVzIHJlcXVlc3Qgd2l0aCBvcHRpb25zICVPJywgaXNIdHRwc1JlcXVlc3QgPyAnaHR0cHMnIDogJ2h0dHAnLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxGc1Jlc3BvbnNlPigocmVzb2x2ZSwgcmVqZWN0KTogYW55ID0+IHtcbiAgICAgIGxldCByZXEgPSBhZ2VudC5yZXF1ZXN0KG9wdGlvbnMsIHJlcyA9PiB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBqdXN0IGJlIHN1cmUgdGhhdCByZXNwb25zZSB3aWxsIG5vdCBiZSBjYWxsZWQgYWZ0ZXIgcmVxdWVzdCBpcyBhYm9ydGVkICovXG4gICAgICAgIGlmICghcmVxIHx8IHJlcS5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0cmVhbSA9IHJlcztcbiAgICAgICAgZGVidWcoJ1Jlc3BvbnNlIHN0YXR1c0NvZGU6ICVkLCBSZXNwb25zZSBIZWFkZXJzOiAlTycsIHJlcy5zdGF0dXNDb2RlLCByZXMuaGVhZGVycyk7XG5cbiAgICAgICAgY29uc3QgY29tcHJlc3NIZWFkZXJzID0gcmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXTtcblxuICAgICAgICBpZiAoY29tcHJlc3NIZWFkZXJzICYmIGNvbXByZXNzSGVhZGVycy5sZW5ndGggJiYgWydnemlwJywgJ2NvbXByZXNzJywgJ2RlZmxhdGUnXS5zb21lKCh2KSA9PiBjb21wcmVzc0hlYWRlcnMuaW5kZXhPZih2KSA+IC0xKSkge1xuICAgICAgICAgIC8vIGFkZCB0aGUgdW56aXBwZXIgdG8gdGhlIGJvZHkgc3RyZWFtIHByb2Nlc3NpbmcgcGlwZWxpbmVcbiAgICAgICAgICBzdHJlYW0gPSByZXMuc3RhdHVzQ29kZSA9PT0gMjA0ID8gc3RyZWFtIDogc3RyZWFtLnBpcGUoemxpYi5jcmVhdGVVbnppcCgpKTtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGNvbnRlbnQtZW5jb2RpbmcgaW4gb3JkZXIgdG8gbm90IGNvbmZ1c2UgZG93bnN0cmVhbSBvcGVyYXRpb25zXG4gICAgICAgICAgZGVsZXRlIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzcG9uc2U6IEZzUmVzcG9uc2UgPSB7XG4gICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXMuc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgICBoZWFkZXJzOiByZXMuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgZGF0YToge30sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gd2UgbmVlZCB0byBmb2xsb3cgcmVkaXJlY3Qgc28gbWFrZSBzYW1lIHJlcXVlc3Qgd2l0aCBuZXcgbG9jYXRpb25cbiAgICAgICAgaWYgKFszMDEsIDMwMl0uaW5kZXhPZihyZXMuc3RhdHVzQ29kZSkgPiAtMSkge1xuICAgICAgICAgIGRlYnVnKCdSZWRpcmVjdCByZWNlaXZlZCAlcycsIHJlcy5zdGF0dXNDb2RlKTtcblxuICAgICAgICAgIGlmICh0aGlzLnJlZGlyZWN0SG9vcHMgPj0gTUFYX1JFRElSRUNUUykge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYE1heCByZWRpcmVjdHMgKCR7dGhpcy5yZWRpcmVjdEhvb3BzfSkgcmVhY2hlZC4gRXhpdGluZ2AsIGNvbmZpZywgcmVzcG9uc2UsIEZzUmVxdWVzdEVycm9yQ29kZS5SRURJUkVDVCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHVybCA9IHJlcy5oZWFkZXJzWydsb2NhdGlvbiddO1xuXG4gICAgICAgICAgaWYgKCF1cmwgfHwgdXJsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYFJlZGlyZWN0IGhlYWRlciBsb2NhdGlvbiBub3QgZm91bmRgLCBjb25maWcsIHJlc3BvbnNlLCBGc1JlcXVlc3RFcnJvckNvZGUuUkVESVJFQ1QpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5yZWRpcmVjdFBhdGhzLmluZGV4T2YodXJsKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgUmVkaXJlY3QgbG9vcCBkZXRlY3RlZCBhdCB1cmwgJHt1cmx9YCwgY29uZmlnLCByZXNwb25zZSwgRnNSZXF1ZXN0RXJyb3JDb2RlLlJFRElSRUNUKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZWRpcmVjdFBhdGhzLnB1c2godXJsKTtcbiAgICAgICAgICB0aGlzLnJlZGlyZWN0SG9vcHMrKztcblxuICAgICAgICAgIC8vIGZyZWUgcmVzb3VyY2VzXG4gICAgICAgICAgcmVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlcSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGRlYnVnKCdSZWRpcmVjdGluZyByZXF1ZXN0IHRvICVzIChob29wLWNvdW50OiAlZCknLCB1cmwsIHRoaXMucmVkaXJlY3RIb29wcyk7XG5cbiAgICAgICAgICAvLyBjbGVhciBjYW5jZWwgdG9rZW4gdG8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgICAgICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4uY2FuY2VsKENBTkNFTF9DTEVBUik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcy5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZywgeyB1cmwgfSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXNwb25zZUJ1ZmZlciA9IFtdO1xuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCBjaHVuayA9PiByZXNwb25zZUJ1ZmZlci5wdXNoKGNodW5rKSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGl0cyBoYXJkIHRvIHRlc3Qgc29ja2V0IGV2ZW50cyB3aXRoIGplc3QgYW5kIG5vY2sgLSB0ZXN0ZWQgbWFudWFsbHkgKi9cbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgcmVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlcSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNwb25zZUJ1ZmZlciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGRlYnVnKCdSZXF1ZXN0IGVycm9yOiBBYm9ydGVkICVPJywgZXJyKTtcblxuICAgICAgICAgIGlmIChyZXEuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKGVyci5tZXNzYWdlLCBjb25maWcsIG51bGwsIEZzUmVxdWVzdEVycm9yQ29kZS5ORVRXT1JLKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFueSByZXNwb25zZSBkYXRhIGluc2lkZVxuICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSAhPT0gMjA0KSB7XG4gICAgICAgICAgICAvLyBwcmVwYXJlIHJlc3BvbnNlXG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gQnVmZmVyLmNvbmNhdChyZXNwb25zZUJ1ZmZlcik7XG4gICAgICAgICAgICByZXNwb25zZSA9IHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmcmVlIHJlc291cmNlc1xuICAgICAgICAgIHJlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXEgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICByZXNwb25zZUJ1ZmZlciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmICg1MDAgPD0gcmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cyA8PSA1OTkpIHtcbiAgICAgICAgICAgIC8vIHNlcnZlciBlcnJvciB0aHJvd1xuICAgICAgICAgICAgZGVidWcoJ1NlcnZlciBlcnJvcig1eHgpIC0gJU8nLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgU2VydmVyIGVycm9yICR7dXJsfWAsIGNvbmZpZywgcmVzcG9uc2UsIEZzUmVxdWVzdEVycm9yQ29kZS5TRVJWRVIpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKDQwMCA8PSByZXNwb25zZS5zdGF0dXMgJiYgcmVzcG9uc2Uuc3RhdHVzIDw9IDQ5OSkge1xuICAgICAgICAgICAgZGVidWcoJ1JlcXVlc3QgZXJyb3IoNHh4KSAtICVPJywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYFJlcXVlc3QgZXJyb3IgJHt1cmx9YCwgY29uZmlnLCByZXNwb25zZSwgRnNSZXF1ZXN0RXJyb3JDb2RlLlJFUVVFU1QpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWJ1ZygnUmVxdWVzdCBlbmRzOiAlTycsIHJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgY29uZmlnLmNhbmNlbFRva2VuXG4gICAgICAgICAgLmdldFNvdXJjZSgpXG4gICAgICAgICAgLnRoZW4ocmVhc29uID0+IHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgaWYgcHJvbWlzZSBpcyByZXNvbHZlZCBieSBzeXN0ZW1cbiAgICAgICAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLm1lc3NhZ2UgPT09IENBTkNFTF9DTEVBUikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBpZiByZXF1ZXN0IGlzIGRvbmUgY2FuY2VsIHRva2VuIHNob3VsZCBub3QgdGhyb3cgYW55IGVycm9yICovXG4gICAgICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgICByZXEgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWJ1ZygnUmVxdWVzdCBjYW5jZWxlZCBieSB1c2VyICVzLCBjb25maWc6ICVPJywgcmVhc29uLCBjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYFJlcXVlc3QgYWJvcnRlZC4gUmVhc29uOiAke3JlYXNvbn1gLCBjb25maWcsIG51bGwsIEZzUmVxdWVzdEVycm9yQ29kZS5BQk9SVEVEKSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogb25seSBmb3Igc2FmZXR5ICovXG4gICAgICAgICAgLmNhdGNoKCgpID0+IHsvKiBlbXB0eSAqL30pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgcmVxLnNldFRpbWVvdXQoY29uZmlnLnRpbWVvdXQsICgpID0+IHtcbiAgICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcignUmVxdWVzdCB0aW1lb3V0JywgY29uZmlnLCBudWxsLCBGc1JlcXVlc3RFcnJvckNvZGUuVElNRU9VVCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVxLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgIGlmICghcmVxIHx8IHJlcS5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoJ1JlcXVlc3QgZXJyb3I6ICVzIC0gJU8nLCBlcnIsIGVyci5jb2RlKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYFJlcXVlc3QgZXJyb3I6ICR7ZXJyLmNvZGV9YCwgY29uZmlnLCBudWxsLCBGc1JlcXVlc3RFcnJvckNvZGUuTkVUV09SSykpO1xuICAgICAgfSk7XG5cbiAgICAgIHJlcS5lbmQoZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==
