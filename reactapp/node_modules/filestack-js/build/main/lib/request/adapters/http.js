"use strict";
/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var url = require("url");
var zlib = require("zlib");
var debug_1 = require("debug");
var utils_1 = require("../../utils");
var utils = require("../utils");
var helpers_1 = require("./../helpers");
var error_1 = require("../error");
var HTTPS_REGEXP = /https:?/;
var MAX_REDIRECTS = 10;
var CANCEL_CLEAR = "FsCleanMemory";
var debug = debug_1.default('fs:request:http');
var HttpAdapter = /** @class */ (function () {
    function HttpAdapter() {
        this.redirectHoops = 0;
        this.redirectPaths = [];
    }
    HttpAdapter.prototype.request = function (config) {
        var _this = this;
        // if this option is unspecified set it by default
        if (typeof config.filestackHeaders === 'undefined') {
            config.filestackHeaders = true;
        }
        config.headers = helpers_1.normalizeHeaders(config.headers);
        var _a = helpers_1.prepareData(config), data = _a.data, headers = _a.headers;
        headers = helpers_1.set(headers, 'user-agent', "filestack-request/" + utils_1.getVersion());
        // for now we are not using streams
        if (data) {
            debug('Request data %O', data);
            if (!Buffer.isBuffer(data)) {
                if (!utils.isString(data)) {
                    return Promise.reject(new error_1.FsRequestError('Data must be a string, JSON or a Buffer', config));
                }
                data = Buffer.from(data, 'utf-8');
            }
            headers = helpers_1.set(headers, 'content-length', data.length, true);
        }
        // HTTP basic authentication
        var auth;
        if (config.auth) {
            if (!config.auth.username || config.auth.username.length === 0) {
                return Promise.reject(new error_1.FsRequestError("Basic auth: username is required " + config.auth, config));
            }
            auth = config.auth.username + ":" + config.auth.password;
        }
        // Parse url
        var parsed = url.parse(config.url);
        // try to add default https protocol
        if (!parsed.protocol) {
            parsed = url.parse("https://" + config.url);
        }
        /* istanbul ignore next: just be sure that the host is parsed correctly, not needed to test */
        if (!parsed.host) {
            return Promise.reject(new error_1.FsRequestError("Cannot parse provided url " + config.url, config));
        }
        // normalize auth header
        if (auth && headers.Authorization) {
            delete headers.Authorization;
        }
        var isHttpsRequest = HTTPS_REGEXP.test(parsed.protocol);
        var agent = isHttpsRequest ? require('https') : require('http');
        var options = {
            path: helpers_1.combineURL(parsed.path, config.params),
            host: parsed.host,
            port: parsed.port,
            protocol: parsed.protocol,
            method: config.method.toUpperCase(),
            headers: headers,
            agent: new agent.Agent(),
            auth: auth,
        };
        debug('Starting %s request with options %O', isHttpsRequest ? 'https' : 'http', options);
        return new Promise(function (resolve, reject) {
            var req = agent.request(options, function (res) {
                /* istanbul ignore next: just be sure that response will not be called after request is aborted */
                if (!req || req.aborted) {
                    return reject(new error_1.FsRequestError('Request aborted', config));
                }
                var stream = res;
                debug('Response statusCode: %d, Response Headers: %O', res.statusCode, res.headers);
                var compressHeaders = res.headers['content-encoding'];
                if (compressHeaders && compressHeaders.length && ['gzip', 'compress', 'deflate'].some(function (v) { return compressHeaders.indexOf(v) > -1; })) {
                    // add the unzipper to the body stream processing pipeline
                    stream = res.statusCode === 204 ? stream : stream.pipe(zlib.createUnzip());
                    // remove the content-encoding in order to not confuse downstream operations
                    delete res.headers['content-encoding'];
                }
                var response = {
                    status: res.statusCode,
                    statusText: res.statusMessage,
                    headers: res.headers,
                    config: config,
                    data: {},
                };
                // we need to follow redirect so make same request with new location
                if ([301, 302].indexOf(res.statusCode) > -1) {
                    debug('Redirect received %s', res.statusCode);
                    if (_this.redirectHoops >= MAX_REDIRECTS) {
                        return reject(new error_1.FsRequestError("Max redirects (" + _this.redirectHoops + ") reached. Exiting", config, response, error_1.FsRequestErrorCode.REDIRECT));
                    }
                    var url_1 = res.headers['location'];
                    if (!url_1 || url_1.length === 0) {
                        return reject(new error_1.FsRequestError("Redirect header location not found", config, response, error_1.FsRequestErrorCode.REDIRECT));
                    }
                    if (_this.redirectPaths.indexOf(url_1) > -1) {
                        return reject(new error_1.FsRequestError("Redirect loop detected at url " + url_1, config, response, error_1.FsRequestErrorCode.REDIRECT));
                    }
                    _this.redirectPaths.push(url_1);
                    _this.redirectHoops++;
                    // free resources
                    res = undefined;
                    req = undefined;
                    debug('Redirecting request to %s (hoop-count: %d)', url_1, _this.redirectHoops);
                    // clear cancel token to avoid memory leak
                    if (config.cancelToken) {
                        config.cancelToken.cancel(CANCEL_CLEAR);
                    }
                    return resolve(_this.request(Object.assign({}, config, { url: url_1 })));
                }
                var responseBuffer = [];
                stream.on('data', function (chunk) { return responseBuffer.push(chunk); });
                /* istanbul ignore next: its hard to test socket events with jest and nock - tested manually */
                stream.on('error', function (err) {
                    res = undefined;
                    req = undefined;
                    responseBuffer = undefined;
                    debug('Request error: Aborted %O', err);
                    if (req.aborted) {
                        return;
                    }
                    return reject(new error_1.FsRequestError(err.message, config, null, error_1.FsRequestErrorCode.NETWORK));
                });
                stream.on('end', function () {
                    // check if there is any response data inside
                    if (res.statusCode !== 204) {
                        // prepare response
                        response.data = Buffer.concat(responseBuffer);
                        response = helpers_1.parseResponse(response);
                    }
                    else {
                        response.data = null;
                    }
                    // free resources
                    res = undefined;
                    req = undefined;
                    responseBuffer = undefined;
                    if (500 <= response.status && response.status <= 599) {
                        // server error throw
                        debug('Server error(5xx) - %O', response);
                        return reject(new error_1.FsRequestError("Server error " + url, config, response, error_1.FsRequestErrorCode.SERVER));
                    }
                    else if (400 <= response.status && response.status <= 499) {
                        debug('Request error(4xx) - %O', response);
                        return reject(new error_1.FsRequestError("Request error " + url, config, response, error_1.FsRequestErrorCode.REQUEST));
                    }
                    debug('Request ends: %O', response);
                    return resolve(response);
                });
            });
            if (config.cancelToken) {
                config.cancelToken
                    .getSource()
                    .then(function (reason) {
                    // do nothing if promise is resolved by system
                    if (reason && reason.message === CANCEL_CLEAR) {
                        return;
                    }
                    /* istanbul ignore next: if request is done cancel token should not throw any error */
                    if (req) {
                        req.abort();
                        req = null;
                    }
                    debug('Request canceled by user %s, config: %O', reason, config);
                    return reject(new error_1.FsRequestError("Request aborted. Reason: " + reason, config, null, error_1.FsRequestErrorCode.ABORTED));
                })
                    /* istanbul ignore next: only for safety */
                    .catch(function () { });
            }
            if (config.timeout) {
                req.setTimeout(config.timeout, function () {
                    req.abort();
                    return reject(new error_1.FsRequestError('Request timeout', config, null, error_1.FsRequestErrorCode.TIMEOUT));
                });
            }
            req.on('error', function (err) {
                if (!req || req.aborted) {
                    return;
                }
                debug('Request error: %s - %O', err, err.code);
                return reject(new error_1.FsRequestError("Request error: " + err.code, config, null, error_1.FsRequestErrorCode.NETWORK));
            });
            req.end(data);
        });
    };
    return HttpAdapter;
}());
exports.HttpAdapter = HttpAdapter;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9hZGFwdGVycy9odHRwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7O0FBRUgseUJBQTJCO0FBQzNCLDJCQUE2QjtBQUM3QiwrQkFBMEI7QUFHMUIscUNBQXlDO0FBRXpDLGdDQUFrQztBQUNsQyx3Q0FBMEc7QUFDMUcsa0NBQThEO0FBRTlELElBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQztBQUMvQixJQUFNLGFBQWEsR0FBRyxFQUFFLENBQUM7QUFDekIsSUFBTSxZQUFZLEdBQUcsZUFBZSxDQUFDO0FBQ3JDLElBQU0sS0FBSyxHQUFHLGVBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBRXZDO0lBQUE7UUFDVSxrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUNsQixrQkFBYSxHQUFHLEVBQUUsQ0FBQztJQWdPN0IsQ0FBQztJQTlOQyw2QkFBTyxHQUFQLFVBQVEsTUFBd0I7UUFBaEMsaUJBNk5DO1FBNU5DLGtEQUFrRDtRQUNsRCxJQUFJLE9BQU8sTUFBTSxDQUFDLGdCQUFnQixLQUFLLFdBQVcsRUFBRTtZQUNsRCxNQUFNLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO1NBQ2hDO1FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRywwQkFBZ0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFOUMsSUFBQSxrQ0FBdUMsRUFBckMsY0FBSSxFQUFFLG9CQUErQixDQUFDO1FBRTVDLE9BQU8sR0FBRyxhQUFTLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRSx1QkFBcUIsa0JBQVUsRUFBSSxDQUFDLENBQUM7UUFFaEYsbUNBQW1DO1FBQ25DLElBQUksSUFBSSxFQUFFO1lBQ1IsS0FBSyxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxDQUFDO1lBRS9CLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUMxQixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDekIsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksc0JBQWMsQ0FBQyx5Q0FBeUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2lCQUM5RjtnQkFFRCxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDbkM7WUFFRCxPQUFPLEdBQUcsYUFBUyxDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ25FO1FBRUQsNEJBQTRCO1FBQzVCLElBQUksSUFBSSxDQUFDO1FBQ1QsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQzlELE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLHNCQUFjLENBQUMsc0NBQW9DLE1BQU0sQ0FBQyxJQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQzthQUN0RztZQUVELElBQUksR0FBTSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsU0FBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVUsQ0FBQztTQUMxRDtRQUVELFlBQVk7UUFDWixJQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVuQyxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDcEIsTUFBTSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsYUFBVyxNQUFNLENBQUMsR0FBSyxDQUFDLENBQUM7U0FDN0M7UUFFRCw4RkFBOEY7UUFDOUYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDaEIsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksc0JBQWMsQ0FBQywrQkFBNkIsTUFBTSxDQUFDLEdBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQzlGO1FBRUQsd0JBQXdCO1FBQ3hCLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxhQUFhLEVBQUU7WUFDakMsT0FBTyxPQUFPLENBQUMsYUFBYSxDQUFDO1NBQzlCO1FBRUQsSUFBTSxjQUFjLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDMUQsSUFBTSxLQUFLLEdBQUcsY0FBYyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVsRSxJQUFNLE9BQU8sR0FBRztZQUNkLElBQUksRUFBRSxvQkFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQztZQUM1QyxJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7WUFDakIsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJO1lBQ2pCLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUTtZQUN6QixNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUU7WUFDbkMsT0FBTyxFQUFFLE9BQU87WUFDaEIsS0FBSyxFQUFFLElBQUksS0FBSyxDQUFDLEtBQUssRUFBRTtZQUN4QixJQUFJLEVBQUUsSUFBSTtTQUNYLENBQUM7UUFFRixLQUFLLENBQUMscUNBQXFDLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUV6RixPQUFPLElBQUksT0FBTyxDQUFhLFVBQUMsT0FBTyxFQUFFLE1BQU07WUFDN0MsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsVUFBQSxHQUFHO2dCQUNsQyxrR0FBa0c7Z0JBQ2xHLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRTtvQkFDdkIsT0FBTyxNQUFNLENBQUMsSUFBSSxzQkFBYyxDQUFDLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7aUJBQzlEO2dCQUVELElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQztnQkFDakIsS0FBSyxDQUFDLCtDQUErQyxFQUFFLEdBQUcsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUVwRixJQUFNLGVBQWUsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7Z0JBRXhELElBQUksZUFBZSxJQUFJLGVBQWUsQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFDLENBQUMsSUFBSyxPQUFBLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQS9CLENBQStCLENBQUMsRUFBRTtvQkFDN0gsMERBQTBEO29CQUMxRCxNQUFNLEdBQUcsR0FBRyxDQUFDLFVBQVUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztvQkFDM0UsNEVBQTRFO29CQUM1RSxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztpQkFDeEM7Z0JBRUQsSUFBSSxRQUFRLEdBQWU7b0JBQ3pCLE1BQU0sRUFBRSxHQUFHLENBQUMsVUFBVTtvQkFDdEIsVUFBVSxFQUFFLEdBQUcsQ0FBQyxhQUFhO29CQUM3QixPQUFPLEVBQUUsR0FBRyxDQUFDLE9BQU87b0JBQ3BCLE1BQU0sUUFBQTtvQkFDTixJQUFJLEVBQUUsRUFBRTtpQkFDVCxDQUFDO2dCQUVGLG9FQUFvRTtnQkFDcEUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO29CQUMzQyxLQUFLLENBQUMsc0JBQXNCLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO29CQUU5QyxJQUFJLEtBQUksQ0FBQyxhQUFhLElBQUksYUFBYSxFQUFFO3dCQUN2QyxPQUFPLE1BQU0sQ0FBQyxJQUFJLHNCQUFjLENBQUMsb0JBQWtCLEtBQUksQ0FBQyxhQUFhLHVCQUFvQixFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsMEJBQWtCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztxQkFDNUk7b0JBRUQsSUFBTSxLQUFHLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztvQkFFcEMsSUFBSSxDQUFDLEtBQUcsSUFBSSxLQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTt3QkFDNUIsT0FBTyxNQUFNLENBQUMsSUFBSSxzQkFBYyxDQUFDLG9DQUFvQyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsMEJBQWtCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztxQkFDeEg7b0JBRUQsSUFBSSxLQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxLQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTt3QkFDeEMsT0FBTyxNQUFNLENBQUMsSUFBSSxzQkFBYyxDQUFDLG1DQUFpQyxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSwwQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO3FCQUMxSDtvQkFFRCxLQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFHLENBQUMsQ0FBQztvQkFDN0IsS0FBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO29CQUVyQixpQkFBaUI7b0JBQ2pCLEdBQUcsR0FBRyxTQUFTLENBQUM7b0JBQ2hCLEdBQUcsR0FBRyxTQUFTLENBQUM7b0JBRWhCLEtBQUssQ0FBQyw0Q0FBNEMsRUFBRSxLQUFHLEVBQUUsS0FBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO29CQUU3RSwwQ0FBMEM7b0JBQzFDLElBQUksTUFBTSxDQUFDLFdBQVcsRUFBRTt3QkFDdEIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7cUJBQ3pDO29CQUVELE9BQU8sT0FBTyxDQUFDLEtBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsR0FBRyxPQUFBLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbEU7Z0JBRUQsSUFBSSxjQUFjLEdBQUcsRUFBRSxDQUFDO2dCQUN4QixNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxVQUFBLEtBQUssSUFBSSxPQUFBLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQTFCLENBQTBCLENBQUMsQ0FBQztnQkFFdkQsK0ZBQStGO2dCQUMvRixNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxVQUFBLEdBQUc7b0JBQ3BCLEdBQUcsR0FBRyxTQUFTLENBQUM7b0JBQ2hCLEdBQUcsR0FBRyxTQUFTLENBQUM7b0JBQ2hCLGNBQWMsR0FBRyxTQUFTLENBQUM7b0JBRTNCLEtBQUssQ0FBQywyQkFBMkIsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFFeEMsSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO3dCQUNmLE9BQU87cUJBQ1I7b0JBRUQsT0FBTyxNQUFNLENBQUMsSUFBSSxzQkFBYyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSwwQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLENBQUMsQ0FBQztnQkFFSCxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRTtvQkFDZiw2Q0FBNkM7b0JBQzdDLElBQUksR0FBRyxDQUFDLFVBQVUsS0FBSyxHQUFHLEVBQUU7d0JBQzFCLG1CQUFtQjt3QkFDbkIsUUFBUSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO3dCQUM5QyxRQUFRLEdBQUcsdUJBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztxQkFDcEM7eUJBQU07d0JBQ0wsUUFBUSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7cUJBQ3RCO29CQUVELGlCQUFpQjtvQkFDakIsR0FBRyxHQUFHLFNBQVMsQ0FBQztvQkFDaEIsR0FBRyxHQUFHLFNBQVMsQ0FBQztvQkFFaEIsY0FBYyxHQUFHLFNBQVMsQ0FBQztvQkFFM0IsSUFBSSxHQUFHLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLEdBQUcsRUFBRTt3QkFDcEQscUJBQXFCO3dCQUNyQixLQUFLLENBQUMsd0JBQXdCLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBQzFDLE9BQU8sTUFBTSxDQUFDLElBQUksc0JBQWMsQ0FBQyxrQkFBZ0IsR0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsMEJBQWtCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztxQkFDdkc7eUJBQU0sSUFBSSxHQUFHLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLEdBQUcsRUFBRTt3QkFDM0QsS0FBSyxDQUFDLHlCQUF5QixFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUMzQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLHNCQUFjLENBQUMsbUJBQWlCLEdBQUssRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLDBCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7cUJBQ3pHO29CQUVELEtBQUssQ0FBQyxrQkFBa0IsRUFBRSxRQUFRLENBQUMsQ0FBQztvQkFDcEMsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQzNCLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxJQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUU7Z0JBQ3RCLE1BQU0sQ0FBQyxXQUFXO3FCQUNmLFNBQVMsRUFBRTtxQkFDWCxJQUFJLENBQUMsVUFBQSxNQUFNO29CQUNWLDhDQUE4QztvQkFDOUMsSUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLE9BQU8sS0FBSyxZQUFZLEVBQUU7d0JBQzdDLE9BQU87cUJBQ1I7b0JBRUQsc0ZBQXNGO29CQUN0RixJQUFJLEdBQUcsRUFBRTt3QkFDUCxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7d0JBQ1osR0FBRyxHQUFHLElBQUksQ0FBQztxQkFDWjtvQkFFRCxLQUFLLENBQUMseUNBQXlDLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO29CQUNqRSxPQUFPLE1BQU0sQ0FBQyxJQUFJLHNCQUFjLENBQUMsOEJBQTRCLE1BQVEsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLDBCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBQ3BILENBQUMsQ0FBQztvQkFDRiwyQ0FBMkM7cUJBQzFDLEtBQUssQ0FBQyxjQUFrQixDQUFDLENBQUMsQ0FBQzthQUMvQjtZQUVELElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRTtnQkFDbEIsR0FBRyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFO29CQUM3QixHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7b0JBQ1osT0FBTyxNQUFNLENBQUMsSUFBSSxzQkFBYyxDQUFDLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsMEJBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDakcsQ0FBQyxDQUFDLENBQUM7YUFDSjtZQUVELEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLFVBQUEsR0FBRztnQkFDakIsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO29CQUN2QixPQUFPO2lCQUNSO2dCQUVELEtBQUssQ0FBQyx3QkFBd0IsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMvQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLHNCQUFjLENBQUMsb0JBQWtCLEdBQUcsQ0FBQyxJQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSwwQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQzVHLENBQUMsQ0FBQyxDQUFDO1lBRUgsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoQixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDSCxrQkFBQztBQUFELENBbE9BLEFBa09DLElBQUE7QUFsT1ksa0NBQVciLCJmaWxlIjoibGliL3JlcXVlc3QvYWRhcHRlcnMvaHR0cC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgRmlsZXN0YWNrXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgKiBhcyB6bGliIGZyb20gJ3psaWInO1xuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJztcblxuaW1wb3J0IHsgQWRhcHRlckludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IGdldFZlcnNpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBGc1JlcXVlc3RPcHRpb25zLCBGc1Jlc3BvbnNlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcHJlcGFyZURhdGEsIHBhcnNlUmVzcG9uc2UsIGNvbWJpbmVVUkwsIHNldCBhcyBzZXRIZWFkZXIsIG5vcm1hbGl6ZUhlYWRlcnMgfSBmcm9tICcuLy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgRnNSZXF1ZXN0RXJyb3JDb2RlLCBGc1JlcXVlc3RFcnJvciB9IGZyb20gJy4uL2Vycm9yJztcblxuY29uc3QgSFRUUFNfUkVHRVhQID0gL2h0dHBzOj8vO1xuY29uc3QgTUFYX1JFRElSRUNUUyA9IDEwO1xuY29uc3QgQ0FOQ0VMX0NMRUFSID0gYEZzQ2xlYW5NZW1vcnlgO1xuY29uc3QgZGVidWcgPSBEZWJ1ZygnZnM6cmVxdWVzdDpodHRwJyk7XG5cbmV4cG9ydCBjbGFzcyBIdHRwQWRhcHRlciBpbXBsZW1lbnRzIEFkYXB0ZXJJbnRlcmZhY2Uge1xuICBwcml2YXRlIHJlZGlyZWN0SG9vcHMgPSAwO1xuICBwcml2YXRlIHJlZGlyZWN0UGF0aHMgPSBbXTtcblxuICByZXF1ZXN0KGNvbmZpZzogRnNSZXF1ZXN0T3B0aW9ucykge1xuICAgIC8vIGlmIHRoaXMgb3B0aW9uIGlzIHVuc3BlY2lmaWVkIHNldCBpdCBieSBkZWZhdWx0XG4gICAgaWYgKHR5cGVvZiBjb25maWcuZmlsZXN0YWNrSGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZy5maWxlc3RhY2tIZWFkZXJzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25maWcuaGVhZGVycyA9IG5vcm1hbGl6ZUhlYWRlcnMoY29uZmlnLmhlYWRlcnMpO1xuXG4gICAgbGV0IHsgZGF0YSwgaGVhZGVycyB9ID0gcHJlcGFyZURhdGEoY29uZmlnKTtcblxuICAgIGhlYWRlcnMgPSBzZXRIZWFkZXIoaGVhZGVycywgJ3VzZXItYWdlbnQnLCBgZmlsZXN0YWNrLXJlcXVlc3QvJHtnZXRWZXJzaW9uKCl9YCk7XG5cbiAgICAvLyBmb3Igbm93IHdlIGFyZSBub3QgdXNpbmcgc3RyZWFtc1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBkZWJ1ZygnUmVxdWVzdCBkYXRhICVPJywgZGF0YSk7XG5cbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIGlmICghdXRpbHMuaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKCdEYXRhIG11c3QgYmUgYSBzdHJpbmcsIEpTT04gb3IgYSBCdWZmZXInLCBjb25maWcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAndXRmLTgnKTtcbiAgICAgIH1cblxuICAgICAgaGVhZGVycyA9IHNldEhlYWRlcihoZWFkZXJzLCAnY29udGVudC1sZW5ndGgnLCBkYXRhLmxlbmd0aCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGxldCBhdXRoO1xuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgaWYgKCFjb25maWcuYXV0aC51c2VybmFtZSB8fCBjb25maWcuYXV0aC51c2VybmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgQmFzaWMgYXV0aDogdXNlcm5hbWUgaXMgcmVxdWlyZWQgJHtjb25maWcuYXV0aH1gLCBjb25maWcpKTtcbiAgICAgIH1cblxuICAgICAgYXV0aCA9IGAke2NvbmZpZy5hdXRoLnVzZXJuYW1lfToke2NvbmZpZy5hdXRoLnBhc3N3b3JkfWA7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdXJsXG4gICAgbGV0IHBhcnNlZCA9IHVybC5wYXJzZShjb25maWcudXJsKTtcblxuICAgIC8vIHRyeSB0byBhZGQgZGVmYXVsdCBodHRwcyBwcm90b2NvbFxuICAgIGlmICghcGFyc2VkLnByb3RvY29sKSB7XG4gICAgICBwYXJzZWQgPSB1cmwucGFyc2UoYGh0dHBzOi8vJHtjb25maWcudXJsfWApO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBqdXN0IGJlIHN1cmUgdGhhdCB0aGUgaG9zdCBpcyBwYXJzZWQgY29ycmVjdGx5LCBub3QgbmVlZGVkIHRvIHRlc3QgKi9cbiAgICBpZiAoIXBhcnNlZC5ob3N0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKGBDYW5ub3QgcGFyc2UgcHJvdmlkZWQgdXJsICR7Y29uZmlnLnVybH1gLCBjb25maWcpKTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgYXV0aCBoZWFkZXJcbiAgICBpZiAoYXV0aCAmJiBoZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzLkF1dGhvcml6YXRpb247XG4gICAgfVxuXG4gICAgY29uc3QgaXNIdHRwc1JlcXVlc3QgPSBIVFRQU19SRUdFWFAudGVzdChwYXJzZWQucHJvdG9jb2wpO1xuICAgIGNvbnN0IGFnZW50ID0gaXNIdHRwc1JlcXVlc3QgPyByZXF1aXJlKCdodHRwcycpIDogcmVxdWlyZSgnaHR0cCcpO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHBhdGg6IGNvbWJpbmVVUkwocGFyc2VkLnBhdGgsIGNvbmZpZy5wYXJhbXMpLFxuICAgICAgaG9zdDogcGFyc2VkLmhvc3QsXG4gICAgICBwb3J0OiBwYXJzZWQucG9ydCxcbiAgICAgIHByb3RvY29sOiBwYXJzZWQucHJvdG9jb2wsXG4gICAgICBtZXRob2Q6IGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBhZ2VudDogbmV3IGFnZW50LkFnZW50KCksXG4gICAgICBhdXRoOiBhdXRoLFxuICAgIH07XG5cbiAgICBkZWJ1ZygnU3RhcnRpbmcgJXMgcmVxdWVzdCB3aXRoIG9wdGlvbnMgJU8nLCBpc0h0dHBzUmVxdWVzdCA/ICdodHRwcycgOiAnaHR0cCcsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPEZzUmVzcG9uc2U+KChyZXNvbHZlLCByZWplY3QpOiBhbnkgPT4ge1xuICAgICAgbGV0IHJlcSA9IGFnZW50LnJlcXVlc3Qob3B0aW9ucywgcmVzID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGp1c3QgYmUgc3VyZSB0aGF0IHJlc3BvbnNlIHdpbGwgbm90IGJlIGNhbGxlZCBhZnRlciByZXF1ZXN0IGlzIGFib3J0ZWQgKi9cbiAgICAgICAgaWYgKCFyZXEgfHwgcmVxLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RyZWFtID0gcmVzO1xuICAgICAgICBkZWJ1ZygnUmVzcG9uc2Ugc3RhdHVzQ29kZTogJWQsIFJlc3BvbnNlIEhlYWRlcnM6ICVPJywgcmVzLnN0YXR1c0NvZGUsIHJlcy5oZWFkZXJzKTtcblxuICAgICAgICBjb25zdCBjb21wcmVzc0hlYWRlcnMgPSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuXG4gICAgICAgIGlmIChjb21wcmVzc0hlYWRlcnMgJiYgY29tcHJlc3NIZWFkZXJzLmxlbmd0aCAmJiBbJ2d6aXAnLCAnY29tcHJlc3MnLCAnZGVmbGF0ZSddLnNvbWUoKHYpID0+IGNvbXByZXNzSGVhZGVycy5pbmRleE9mKHYpID4gLTEpKSB7XG4gICAgICAgICAgLy8gYWRkIHRoZSB1bnppcHBlciB0byB0aGUgYm9keSBzdHJlYW0gcHJvY2Vzc2luZyBwaXBlbGluZVxuICAgICAgICAgIHN0cmVhbSA9IHJlcy5zdGF0dXNDb2RlID09PSAyMDQgPyBzdHJlYW0gOiBzdHJlYW0ucGlwZSh6bGliLmNyZWF0ZVVuemlwKCkpO1xuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29udGVudC1lbmNvZGluZyBpbiBvcmRlciB0byBub3QgY29uZnVzZSBkb3duc3RyZWFtIG9wZXJhdGlvbnNcbiAgICAgICAgICBkZWxldGUgcmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXNwb25zZTogRnNSZXNwb25zZSA9IHtcbiAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNNZXNzYWdlLFxuICAgICAgICAgIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGZvbGxvdyByZWRpcmVjdCBzbyBtYWtlIHNhbWUgcmVxdWVzdCB3aXRoIG5ldyBsb2NhdGlvblxuICAgICAgICBpZiAoWzMwMSwgMzAyXS5pbmRleE9mKHJlcy5zdGF0dXNDb2RlKSA+IC0xKSB7XG4gICAgICAgICAgZGVidWcoJ1JlZGlyZWN0IHJlY2VpdmVkICVzJywgcmVzLnN0YXR1c0NvZGUpO1xuXG4gICAgICAgICAgaWYgKHRoaXMucmVkaXJlY3RIb29wcyA+PSBNQVhfUkVESVJFQ1RTKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgTWF4IHJlZGlyZWN0cyAoJHt0aGlzLnJlZGlyZWN0SG9vcHN9KSByZWFjaGVkLiBFeGl0aW5nYCwgY29uZmlnLCByZXNwb25zZSwgRnNSZXF1ZXN0RXJyb3JDb2RlLlJFRElSRUNUKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdXJsID0gcmVzLmhlYWRlcnNbJ2xvY2F0aW9uJ107XG5cbiAgICAgICAgICBpZiAoIXVybCB8fCB1cmwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgUmVkaXJlY3QgaGVhZGVyIGxvY2F0aW9uIG5vdCBmb3VuZGAsIGNvbmZpZywgcmVzcG9uc2UsIEZzUmVxdWVzdEVycm9yQ29kZS5SRURJUkVDVCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnJlZGlyZWN0UGF0aHMuaW5kZXhPZih1cmwpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKGBSZWRpcmVjdCBsb29wIGRldGVjdGVkIGF0IHVybCAke3VybH1gLCBjb25maWcsIHJlc3BvbnNlLCBGc1JlcXVlc3RFcnJvckNvZGUuUkVESVJFQ1QpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJlZGlyZWN0UGF0aHMucHVzaCh1cmwpO1xuICAgICAgICAgIHRoaXMucmVkaXJlY3RIb29wcysrO1xuXG4gICAgICAgICAgLy8gZnJlZSByZXNvdXJjZXNcbiAgICAgICAgICByZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVxID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgZGVidWcoJ1JlZGlyZWN0aW5nIHJlcXVlc3QgdG8gJXMgKGhvb3AtY291bnQ6ICVkKScsIHVybCwgdGhpcy5yZWRpcmVjdEhvb3BzKTtcblxuICAgICAgICAgIC8vIGNsZWFyIGNhbmNlbCB0b2tlbiB0byBhdm9pZCBtZW1vcnkgbGVha1xuICAgICAgICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5jYW5jZWwoQ0FOQ0VMX0NMRUFSKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLnJlcXVlc3QoT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7IHVybCB9KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3BvbnNlQnVmZmVyID0gW107XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIGNodW5rID0+IHJlc3BvbnNlQnVmZmVyLnB1c2goY2h1bmspKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaXRzIGhhcmQgdG8gdGVzdCBzb2NrZXQgZXZlbnRzIHdpdGggamVzdCBhbmQgbm9jayAtIHRlc3RlZCBtYW51YWxseSAqL1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICByZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVxID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc3BvbnNlQnVmZmVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgZGVidWcoJ1JlcXVlc3QgZXJyb3I6IEFib3J0ZWQgJU8nLCBlcnIpO1xuXG4gICAgICAgICAgaWYgKHJlcS5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoZXJyLm1lc3NhZ2UsIGNvbmZpZywgbnVsbCwgRnNSZXF1ZXN0RXJyb3JDb2RlLk5FVFdPUkspKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW55IHJlc3BvbnNlIGRhdGEgaW5zaWRlXG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlICE9PSAyMDQpIHtcbiAgICAgICAgICAgIC8vIHByZXBhcmUgcmVzcG9uc2VcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSBCdWZmZXIuY29uY2F0KHJlc3BvbnNlQnVmZmVyKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gcGFyc2VSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZyZWUgcmVzb3VyY2VzXG4gICAgICAgICAgcmVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlcSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHJlc3BvbnNlQnVmZmVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKDUwMCA8PSByZXNwb25zZS5zdGF0dXMgJiYgcmVzcG9uc2Uuc3RhdHVzIDw9IDU5OSkge1xuICAgICAgICAgICAgLy8gc2VydmVyIGVycm9yIHRocm93XG4gICAgICAgICAgICBkZWJ1ZygnU2VydmVyIGVycm9yKDV4eCkgLSAlTycsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKGBTZXJ2ZXIgZXJyb3IgJHt1cmx9YCwgY29uZmlnLCByZXNwb25zZSwgRnNSZXF1ZXN0RXJyb3JDb2RlLlNFUlZFUikpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoNDAwIDw9IHJlc3BvbnNlLnN0YXR1cyAmJiByZXNwb25zZS5zdGF0dXMgPD0gNDk5KSB7XG4gICAgICAgICAgICBkZWJ1ZygnUmVxdWVzdCBlcnJvcig0eHgpIC0gJU8nLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgUmVxdWVzdCBlcnJvciAke3VybH1gLCBjb25maWcsIHJlc3BvbnNlLCBGc1JlcXVlc3RFcnJvckNvZGUuUkVRVUVTVCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlYnVnKCdSZXF1ZXN0IGVuZHM6ICVPJywgcmVzcG9uc2UpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW5cbiAgICAgICAgICAuZ2V0U291cmNlKClcbiAgICAgICAgICAudGhlbihyZWFzb24gPT4ge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZyBpZiBwcm9taXNlIGlzIHJlc29sdmVkIGJ5IHN5c3RlbVxuICAgICAgICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ubWVzc2FnZSA9PT0gQ0FOQ0VMX0NMRUFSKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGlmIHJlcXVlc3QgaXMgZG9uZSBjYW5jZWwgdG9rZW4gc2hvdWxkIG5vdCB0aHJvdyBhbnkgZXJyb3IgKi9cbiAgICAgICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICAgICAgICAgIHJlcSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlYnVnKCdSZXF1ZXN0IGNhbmNlbGVkIGJ5IHVzZXIgJXMsIGNvbmZpZzogJU8nLCByZWFzb24sIGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgUmVxdWVzdCBhYm9ydGVkLiBSZWFzb246ICR7cmVhc29ufWAsIGNvbmZpZywgbnVsbCwgRnNSZXF1ZXN0RXJyb3JDb2RlLkFCT1JURUQpKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBvbmx5IGZvciBzYWZldHkgKi9cbiAgICAgICAgICAuY2F0Y2goKCkgPT4gey8qIGVtcHR5ICovfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcudGltZW91dCkge1xuICAgICAgICByZXEuc2V0VGltZW91dChjb25maWcudGltZW91dCwgKCkgPT4ge1xuICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEZzUmVxdWVzdEVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnLCBjb25maWcsIG51bGwsIEZzUmVxdWVzdEVycm9yQ29kZS5USU1FT1VUKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXEub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgaWYgKCFyZXEgfHwgcmVxLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnUmVxdWVzdCBlcnJvcjogJXMgLSAlTycsIGVyciwgZXJyLmNvZGUpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgUmVxdWVzdCBlcnJvcjogJHtlcnIuY29kZX1gLCBjb25maWcsIG51bGwsIEZzUmVxdWVzdEVycm9yQ29kZS5ORVRXT1JLKSk7XG4gICAgICB9KTtcblxuICAgICAgcmVxLmVuZChkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuIl19
